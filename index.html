<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Puissance 4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <link rel="manifest" href="data:application/manifest+json,{\"name\":\"Puissance 4\",\"short_name\":\"P4\",\"display\":\"standalone\",\"background_color\":\"#000\",\"theme_color\":\"#000\",\"icons\":[]}" />
  <style>
    :root {
      --board-color: #0048ff;
      --red-chip: #ff2d26;
      --yellow-chip: #ffeb3b;
      --empty-cell: #fff;
      --animation-duration: 0.3s;
    }

    html, body {
      margin: 0;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 18px;
      background: linear-gradient(to bottom right, #1a1a2e, #16213e); /* Gradient de fond */
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden; /* Emp√™che le d√©bordement des animations */
    }

    #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 20px;
        background: #101020;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    #controls {
      text-align: center;
      margin-bottom: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button, select {
      background: #3a3a5a;
      border: 0;
      color: #e0e0e0;
      padding: 10px 20px;
      border-radius: 8px;
      margin: 5px 0;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.2s ease, transform 0.1s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    button:hover, select:hover {
      background: #4a4a6a;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    select {
      appearance: none; /* Supprime l'apparence par d√©faut sur certains navigateurs */
      -webkit-appearance: none;
      -moz-appearance: none;
      padding-right: 30px; /* Espace pour la fl√®che personnalis√©e */
      background-image: url('data:image/svg+xml;utf8,<svg fill="#e0e0e0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 18px;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      max-width: 420px;
      width: 100%;
      margin: 0 auto;
      gap: 6px;
      background-color: var(--board-color);
      border-radius: 15px;
      padding: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      border: 5px solid #0030c0; /* Bordure plus prononc√©e */
      position: relative;
    }

    .cell {
      background: var(--board-color);
      border-radius: 50%;
      aspect-ratio: 1;
      position: relative;
      cursor: pointer;
      transition: background 0.2s ease;
      overflow: hidden; /* Emp√™che le d√©bordement de l'animation des jetons */
    }

    /* Effet de survol sur les cellules jouables */
    .cell.playable:hover {
        background-color: rgba(255, 255, 255, 0.2);
    }

    .hole {
      content: '';
      position: absolute;
      inset: 6px;
      border-radius: 50%;
      background: var(--empty-cell);
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
    }

    .chip {
      position: absolute;
      inset: 6px;
      border-radius: 50%;
      background-color: transparent;
      transform: translateY(-500%); /* Position initiale pour l'animation */
      animation: drop var(--animation-duration) ease-out forwards;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }

    .chip.red {
      background-color: var(--red-chip);
    }

    .chip.yellow {
      background-color: var(--yellow-chip);
    }

    @keyframes drop {
      from { transform: translateY(-500%); }
      to { transform: translateY(0); }
    }

    #game-status {
        margin-top: 20px;
        font-size: 1.5em;
        font-weight: bold;
        color: #e0e0e0;
        text-align: center;
        min-height: 1.5em; /* Emp√™che le d√©calage du layout */
    }

    @media (max-width: 600px) {
      #board {
        max-width: 350px;
        gap: 4px;
        padding: 8px;
      }
      .cell, .hole, .chip {
        inset: 4px;
      }
      button, select {
        padding: 8px 15px;
        font-size: 0.9rem;
      }
      #game-status {
          font-size: 1.2em;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="controls">
      <select id="mode">
        <option value="1">1 joueur vs IA</option>
        <option value="2">2 joueurs</option>
      </select>
      <select id="difficulty">
        <option value="1">Facile</option>
        <option value="3">Moyen</option>
        <option value="5">Difficile</option>
      </select>
      <button onclick="newGame()">Nouvelle partie</button>
    </div>
    <div id="board"></div>
    <div id="game-status"></div>
  </div>

  <script>
    const ROWS = 6, COLS = 7, EMPTY = 0, RED = 1, YELLOW = 2;
    let board = [], current = RED, vsAI = true, depth = 3;
    let gameActive = false; // Pour g√©rer si le jeu est en cours
    const gameStatusDiv = document.getElementById('game-status');
    const boardElement = document.getElementById('board');

    function initBoard() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(EMPTY));
      boardElement.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r; // Ajout pour r√©f√©rence de ligne
          cell.dataset.c = c;
          const hole = document.createElement('div');
          hole.className = 'hole';
          cell.appendChild(hole);
          cell.addEventListener('click', () => handleCellClick(c));
          boardElement.appendChild(cell);
        }
      }
      gameActive = true;
      updateStatus(`Au tour du joueur ${current === RED ? 'Rouge' : 'Jaune'}`);
      render();
    }

    function render() {
      const cells = document.querySelectorAll('.cell');
      cells.forEach(cell => {
        const r = parseInt(cell.dataset.r);
        const c = parseInt(cell.dataset.c);
        
        // Supprime tous les jetons existants avant de recr√©er
        const existingChip = cell.querySelector('.chip');
        if (existingChip) {
            cell.removeChild(existingChip);
        }

        if (board[r][c] !== EMPTY) {
            const chip = document.createElement('div');
            chip.className = `chip ${board[r][c] === RED ? 'red' : 'yellow'}`;
            cell.appendChild(chip);
        }

        // Ajoute/supprime la classe 'playable' pour l'effet de survol
        if (gameActive && drop(c) !== -1) {
            cell.classList.add('playable');
        } else {
            cell.classList.remove('playable');
        }
      });
    }

    function drop(col) {
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r][col] === EMPTY) return r;
      }
      return -1;
    }

    function handleCellClick(col) {
      if (!gameActive) return; // Emp√™che de jouer si le jeu est termin√©

      // Permet au joueur de cliquer uniquement si ce n'est pas le tour de l'IA ou si le mode n'est pas AI
      if (vsAI && current === YELLOW) return;

      play(col);
    }

    function play(col, isAI = false) {
      const row = drop(col);
      if (row === -1) {
          if (!isAI) updateStatus("Colonne pleine ! Choisissez une autre colonne.", "error");
          return;
      }

      board[row][col] = current;
      render();

      if (win(row, col)) {
        gameActive = false;
        updateStatus(`${current === RED ? 'Rouge' : 'Jaune'} gagne ! üéâ`, "win");
        return;
      }

      if (board[0].every(c => c !== EMPTY)) { // V√©rifie si toutes les cellules de la premi√®re ligne sont occup√©es
        gameActive = false;
        updateStatus('Match nul ! ü§ù', "draw");
        return;
      }

      current = 3 - current; // Change de joueur (1 -> 2, 2 -> 1)
      updateStatus(`Au tour du joueur ${current === RED ? 'Rouge' : 'Jaune'}`);

      if (vsAI && current === YELLOW && gameActive) {
        setTimeout(() => {
          const aiCol = bestMove();
          if (aiCol !== null) { // V√©rifie si l'IA a trouv√© un coup
            play(aiCol, true);
          } else {
            // Cela ne devrait pas arriver si le jeu n'est pas nul et pas gagn√©
            console.warn("L'IA n'a pas trouv√© de coup valide. Jeu termin√© ?");
          }
        }, 700); // D√©lai de l'IA l√©g√®rement augment√© pour l'animation
      }
    }

    function updateStatus(message, type = "info") {
        gameStatusDiv.textContent = message;
        gameStatusDiv.style.color = "#e0e0e0"; // Couleur par d√©faut
        if (type === "win") {
            gameStatusDiv.style.color = "#4CAF50"; // Vert pour la victoire
        } else if (type === "draw") {
            gameStatusDiv.style.color = "#FFC107"; // Orange pour le nul
        } else if (type === "error") {
            gameStatusDiv.style.color = "#F44336"; // Rouge pour l'erreur
        }
    }

    function win(r, c) {
      const player = board[r][c];
      const directions = [[0,1],[1,0],[1,1],[1,-1]]; // Horizontal, Vertical, Diag /, Diag \

      for (const [dr, dc] of directions) {
        let count = 1;
        // V√©rifie dans une direction
        for (let i = 1; i < 4; i++) {
          const nr = r + dr * i;
          const nc = c + dc * i;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === player) {
            count++;
          } else {
            break;
          }
        }
        // V√©rifie dans la direction oppos√©e
        for (let i = 1; i < 4; i++) {
          const nr = r - dr * i;
          const nc = c - dc * i;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === player) {
            count++;
          } else {
            break;
          }
        }
        if (count >= 4) return true;
      }
      return false;
    }

    function scoreWindow(w) {
      let score = 0;
      const redCount = w.filter(v => v === RED).length;
      const yellowCount = w.filter(v => v === YELLOW).length;
      const emptyCount = w.filter(v => v === EMPTY).length;

      // Scores pour le joueur RED (IA est YELLOW, donc RED est maximis√© par l'opposant)
      if (redCount === 4) score += 100000;
      else if (redCount === 3 && emptyCount === 1) score += 50;
      else if (redCount === 2 && emptyCount === 2) score += 10;

      // Scores pour le joueur YELLOW (l'IA)
      if (yellowCount === 4) score -= 100000; // N√©gatif car c'est le score de l'IA (minimisant)
      else if (yellowCount === 3 && emptyCount === 1) score -= 50;
      else if (yellowCount === 2 && emptyCount === 2) score -= 10;
      
      return score;
    }

    function evaluateBoard(currentBoard) {
      let score = 0;

      // Priorit√© au centre
      const centerColumn = currentBoard.map(row => row[Math.floor(COLS / 2)]);
      score += centerColumn.filter(cell => cell === YELLOW).length * 6; // L'IA veut le centre
      score -= centerColumn.filter(cell => cell === RED).length * 3; // L'IA ne veut pas que l'adversaire ait le centre

      // V√©rification des fen√™tres (lignes de 4 jetons)
      // Horizontal
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c <= COLS - 4; c++) {
          const window = [currentBoard[r][c], currentBoard[r][c+1], currentBoard[r][c+2], currentBoard[r][c+3]];
          score += scoreWindow(window);
        }
      }

      // Vertical
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r <= ROWS - 4; r++) {
          const window = [currentBoard[r][c], currentBoard[r+1][c], currentBoard[r+2][c], currentBoard[r+3][c]];
          score += scoreWindow(window);
        }
      }

      // Diagonale positive (haut-gauche vers bas-droite)
      for (let r = 0; r <= ROWS - 4; r++) {
        for (let c = 0; c <= COLS - 4; c++) {
          const window = [currentBoard[r][c], currentBoard[r+1][c+1], currentBoard[r+2][c+2], currentBoard[r+3][c+3]];
          score += scoreWindow(window);
        }
      }

      // Diagonale n√©gative (bas-gauche vers haut-droite)
      for (let r = 3; r < ROWS; r++) {
        for (let c = 0; c <= COLS - 4; c++) {
          const window = [currentBoard[r][c], currentBoard[r-1][c+1], currentBoard[r-2][c+2], currentBoard[r-3][c+3]];
          score += scoreWindow(window);
        }
      }
      return score;
    }

    // Adapte la fonction minimax
    function minimax(currentBoard, depth, alpha, beta, maximizingPlayer) {
      const validMoves = [...Array(COLS).keys()].filter(c => currentBoard[0][c] === EMPTY);

      // V√©rifie si un joueur a gagn√© (terminal node)
      // On doit simuler un coup pour v√©rifier si √ßa gagne, car 'win' d√©pend d'un coup sp√©cifique
      let isTerminal = false;
      for (const col of validMoves) {
          const row = dropInBoard(currentBoard, col); // Utilise une fonction auxiliaire pour simuler un drop
          if (row !== -1) {
              currentBoard[row][col] = maximizingPlayer ? YELLOW : RED; // Simule le coup
              if (winInBoard(currentBoard, row, col)) {
                  isTerminal = true;
              }
              currentBoard[row][col] = EMPTY; // Annule le coup
          }
      }
      if (validMoves.length === 0 || isTerminal || depth === 0) {
        return [evaluateBoard(currentBoard), null];
      }

      if (maximizingPlayer) { // L'IA (Jaune) maximise
        let value = -Infinity;
        let bestCol = null;
        for (const col of validMoves) {
          const newBoard = JSON.parse(JSON.stringify(currentBoard)); // Copie profonde
          const row = dropInBoard(newBoard, col);
          if (row !== -1) {
              newBoard[row][col] = YELLOW;
              const [val] = minimax(newBoard, depth - 1, alpha, beta, false);
              if (val > value) {
                value = val;
                bestCol = col;
              }
              alpha = Math.max(alpha, value);
              if (alpha >= beta) break;
          }
        }
        return [value, bestCol];
      } else { // Joueur (Rouge) minimise
        let value = Infinity;
        let bestCol = null;
        for (const col of validMoves) {
          const newBoard = JSON.parse(JSON.stringify(currentBoard)); // Copie profonde
          const row = dropInBoard(newBoard, col);
          if (row !== -1) {
              newBoard[row][col] = RED;
              const [val] = minimax(newBoard, depth - 1, alpha, beta, true);
              if (val < value) {
                value = val;
                bestCol = col;
              }
              beta = Math.min(beta, value);
              if (alpha >= beta) break;
          }
        }
        return [value, bestCol];
      }
    }

    // Fonctions auxiliaires pour minimax afin d'op√©rer sur une copie du plateau
    function dropInBoard(tempBoard, col) {
        for (let r = ROWS - 1; r >= 0; r--) {
            if (tempBoard[r][col] === EMPTY) return r;
        }
        return -1;
    }

    function winInBoard(tempBoard, r, c) {
        const player = tempBoard[r][c];
        const directions = [[0,1],[1,0],[1,1],[1,-1]];
        for (const [dr, dc] of directions) {
            let count = 1;
            for (let i = 1; i < 4; i++) {
                const nr = r + dr * i;
                const nc = c + dc * i;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && tempBoard[nr][nc] === player) {
                    count++;
                } else {
                    break;
                }
            }
            for (let i = 1; i < 4; i++) {
                const nr = r - dr * i;
                const nc = c - dc * i;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && tempBoard[nr][nc] === player) {
                    count++;
                } else {
                    break;
                }
            }
            if (count >= 4) return true;
        }
        return false;
    }


    function bestMove() {
      // Assurez-vous que l'IA ne joue que si c'est son tour et le jeu est actif
      if (!gameActive || current !== YELLOW) return null; 

      const [value, col] = minimax(board, depth, -Infinity, Infinity, true);
      console.log(`AI chose column ${col} with score ${value}`); // Pour le d√©bogage
      return col;
    }

    function newGame() {
      vsAI = document.getElementById('mode').value === '1';
      depth = parseInt(document.getElementById('difficulty').value);
      current = RED; // Toujours commencer par le joueur Rouge
      initBoard();
    }

    // Initialisation du jeu au chargement de la page
    initBoard();
  </script>
</body>
</html>
