<!-- 
peux-tu me proposer une page HTML compl√®te proposant un jeu puissance 4 avec un design moderne, mettant en √©vidence les pions gagnants avec une animation fun et la possibilit√© de jouer contre l'ordinateur avec plusieurs niveau. L'interface doit √™tre compatible avec les mobiles. Merci d'ajouter ce prompt en commentaire au d√©but du code.
-->
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Puissance 4</title>
  <style>
    :root {
      --bg: #0f1226;
      --panel: #14183a;
      --panel-2: #1b2052;
      --accent: #7c5cff;
      --accent-2: #00e5ff;
      --p1: #ff3b5c;   /* rouge */
      --p2: #ffd83b;   /* jaune */
      --cell-size: min(12vw, 72px);
      --gap: clamp(6px, 1.2vw, 12px);
      --radius: 16px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 800px at 20% 0%, #10143a, #0a0d20 55%), var(--bg);
      color: #e9ecff; display: grid; place-items: center; min-height: 100svh;
    }
    .app {
      width: min(100%, 1100px); padding: 16px; display: grid; gap: 14px;
    }
    header {
      display: grid; gap: 8px; justify-items: center; text-align: center;
    }
    h1 { margin: 0; font-weight: 800; letter-spacing: .3px; font-size: clamp(22px, 4.2vw, 34px); }
    .sub { opacity:.8; font-size: .95rem; }

    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding: clamp(10px, 2.5vw, 18px);
    }

    .toolbar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; }
    .btn, select {
      background: #1e235a; color:#fff; border:1px solid rgba(255,255,255,.15);
      padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight:600; letter-spacing:.2px;
      transition: transform .05s ease, filter .2s ease, background .2s;
    }
    .btn:hover, select:hover { filter: brightness(1.1); }
    .btn:active { transform: translateY(1px); }
    .seg { display:flex; border:1px solid rgba(255,255,255,.15); border-radius:12px; overflow:hidden; }
    .seg button { background:#1e235a; border:0; padding:10px 12px; color:#fff; cursor:pointer; }
    .seg button[aria-pressed="true"] { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color:#0a0d20; font-weight:800; }

    .status { text-align:center; font-weight:700; margin-top:2px; }

    .board-wrap { display:grid; gap: var(--gap); justify-items:center; }
    .board {
      --cols: 7; --rows: 6;
      display:grid; grid-template-columns: repeat(var(--cols), var(--cell-size));
      grid-auto-rows: var(--cell-size);
      gap: var(--gap);
      padding: var(--gap);
      border-radius: calc(var(--radius) * 1.2);
      background: linear-gradient(180deg, #0d1140, #070a29);
      box-shadow: 0 12px 40px rgba(0,0,0,.45), inset 0 0 0 2px rgba(255,255,255,.05);
      position: relative;
      touch-action: manipulation;
      user-select: none;
    }

    .slot {
      width: var(--cell-size); height: var(--cell-size); position: relative; border-radius: 50%;
      background: radial-gradient(circle at 30% 25%, #263190 0%, #111545 55%, #0a0e2e 100%);
      box-shadow: inset 0 8px 18px rgba(0,0,0,.55), inset 0 -6px 14px rgba(255,255,255,.05);
      display:grid; place-items:center; overflow:visible;
    }

    .disc { width: 86%; height: 86%; border-radius: 50%; transform: translateY(-120%);
      box-shadow: inset 0 10px 18px rgba(255,255,255,.25), inset 0 -10px 14px rgba(0,0,0,.4), 0 8px 16px rgba(0,0,0,.35);
      transition: transform .22s cubic-bezier(.2,.8,.2,1);
      position: relative;
    }
    .disc.p1 { background: radial-gradient(circle at 30% 25%, #ff8aa0, var(--p1) 55%, #991a35); }
    .disc.p2 { background: radial-gradient(circle at 30% 25%, #fff2a1, var(--p2) 55%, #c1a316); }

    /* Ghost hover indicator */
    .ghost { position:absolute; top:-42px; left:50%; transform:translateX(-50%);
      width: 60%; height: 60%; border-radius:50%; opacity:.35; pointer-events:none; filter: drop-shadow(0 2px 6px rgba(0,0,0,.45));
    }
    .ghost.p1 { background: var(--p1); }
    .ghost.p2 { background: var(--p2); }

    /* Winning animation */
    @keyframes pop-glow {
      0%, 100% { transform: scale(1) rotate(0deg); box-shadow: 0 0 0 0 rgba(255,255,255,.0); }
      50% { transform: scale(1.12) rotate(2deg); box-shadow: 0 0 18px 6px rgba(255,255,255,.25); }
    }
    .win-ring::after { content:""; position:absolute; inset:-6px; border-radius:50%;
      background: conic-gradient(from 0deg, var(--accent), var(--accent-2), var(--accent)); opacity:.65; filter: blur(6px);
      animation: spin 1.8s linear infinite; z-index:0;
    }
    @keyframes spin { to { transform: rotate(1turn); } }
    .disc.win { animation: pop-glow 1.1s ease-in-out infinite; outline: 3px solid rgba(255,255,255,.25); position:relative; z-index:1; }

    /* Footer tips */
    .tips { opacity:.8; font-size:.9rem; text-align:center; }

    /* Responsive tweaks */
    @media (max-width: 520px) {
      :root { --cell-size: min(13.3vw, 64px); --gap: 8px; }
      .toolbar { gap:8px; }
      .btn, select { padding: 10px 12px; }
    }
  </style>
</head>
<body>
  <main class="app">
    <header>
      <h1>Puissance 4 <span style="font-weight:400; opacity:.85">‚Äì Mode Moderne + IA</span></h1>
      <div class="sub">Joue √† deux ou affronte l'ordinateur (plusieurs niveaux). 100% compatible mobile.</div>
    </header>

    <section class="panel toolbar" aria-label="Contr√¥les">
      <div class="seg" role="group" aria-label="Mode de jeu">
        <button id="modePVP" aria-pressed="false" title="Deux joueurs">üë• 2 joueurs</button>
        <button id="modeCPU" aria-pressed="true" title="Contre l'ordinateur">ü§ñ vs IA</button>
      </div>

      <label>
        Difficult√©
        <select id="difficulty" title="Niveau IA">
          <option value="easy">Facile</option>
          <option value="medium" selected>Moyen</option>
          <option value="hard">Difficile</option>
          <option value="insane">Tr√®s difficile</option>
        </select>
      </label>

      <button class="btn" id="newGame">Nouvelle partie</button>
      <button class="btn" id="undoBtn" title="Annuler le dernier coup">Annuler</button>
    </section>

    <section class="panel board-wrap">
      <div id="status" class="status">√Ä toi de jouer üî¥</div>
      <div id="board" class="board" role="grid" aria-label="Plateau Puissance 4"></div>
      <div class="tips">Astuce : touche 1‚Äì7 pour jouer une colonne. Sur mobile, tape simplement la colonne souhait√©e.</div>
    </section>
  </main>

  <script>
    // --- Configuration du jeu ---
    const COLS = 7, ROWS = 6; // standard
    const P1 = 1, P2 = 2; // joueurs
    const WINLEN = 4;

    // Etat du jeu
    let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    let moves = []; // historique pour undo
    let current = P1;
    let gameOver = false;
    let vsCPU = true;

    // IA: profils de difficult√©
    const depthByLevel = {
      easy: 1,
      medium: 3,
      hard: 4,
      insane: 6,
    };

    const statusEl = document.getElementById('status');
    const boardEl = document.getElementById('board');
    const diffSel = document.getElementById('difficulty');
    const modeCPU = document.getElementById('modeCPU');
    const modePVP = document.getElementById('modePVP');
    const newBtn = document.getElementById('newGame');
    const undoBtn = document.getElementById('undoBtn');

    // Construction visuelle du plateau
    function renderBoard() {
      boardEl.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const slot = document.createElement('div');
          slot.className = 'slot';
          slot.dataset.row = r; slot.dataset.col = c;
          const disc = document.createElement('div');
          disc.className = 'disc';
          slot.appendChild(disc);
          boardEl.appendChild(slot);
        }
      }
      updateUI();
    }

    function updateUI(winLine = null) {
      // Disques
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const idx = r * COLS + c;
          const slot = boardEl.children[idx];
          const disc = slot.querySelector('.disc');
          const val = board[r][c];
          disc.className = 'disc';
          if (val === P1) disc.classList.add('p1');
          else if (val === P2) disc.classList.add('p2');

          // Position d'animation (tomber dans le trou)
          if (val) disc.style.transform = 'translateY(0)'; else disc.style.transform = 'translateY(-120%)';
          slot.classList.toggle('win-ring', false);
        }
      }

      // Animation gagnante
      if (winLine) {
        for (const [r,c] of winLine) {
          const disc = boardEl.children[r*COLS + c].querySelector('.disc');
          disc.classList.add('win');
          boardEl.children[r*COLS + c].classList.add('win-ring');
        }
      } else {
        // Retire l'√©tat win si on relance
        document.querySelectorAll('.disc.win').forEach(d => d.classList.remove('win'));
      }

      const turnStr = current === P1 ? 'üî¥ Rouge' : 'üü° Jaune';
      if (!gameOver) statusEl.textContent = (vsCPU && current===P2) ? 'L\'IA r√©fl√©chit‚Ä¶ ü§ñ' : `√Ä ${turnStr} de jouer`;
    }

    // Renvoie la ligne disponible la plus basse pour une colonne
    function nextRow(col) {
      for (let r = ROWS-1; r >= 0; r--) if (board[r][col] === 0) return r;
      return -1;
    }

    function drop(col, player) {
      const r = nextRow(col);
      if (r === -1) return false;
      board[r][col] = player;
      moves.push({r, c: col});
      return {r, c: col};
    }

    function undo() {
      if (!moves.length || gameOver) return;
      const last = moves.pop();
      board[last.r][last.c] = 0;
      current = current === P1 ? P2 : P1;
      updateUI();
      if (vsCPU && current === P2 && !gameOver) setTimeout(cpuTurn, 120);
    }

    function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

    function checkWin(fromR, fromC) {
      const player = board[fromR][fromC];
      if (!player) return null;
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (const [dr,dc] of dirs) {
        let cells = [[fromR, fromC]];
        // forward
        let r = fromR+dr, c = fromC+dc;
        while (inBounds(r,c) && board[r][c]===player) { cells.push([r,c]); r+=dr; c+=dc; }
        // backward
        r = fromR-dr; c = fromC-dc;
        while (inBounds(r,c) && board[r][c]===player) { cells.push([r,c]); r-=dr; c-=dc; }
        if (cells.length >= WINLEN) return cells.slice(0, WINLEN); // renvoie 4 cellules
      }
      return null;
    }

    function isBoardFull(){ return board[0].every(v => v!==0); }

    function endGame(message, winLine=null) {
      gameOver = true;
      if (winLine) updateUI(winLine); else updateUI();
      statusEl.textContent = message;
    }

    function handleHuman(col) {
      if (gameOver || (vsCPU && current===P2)) return;
      const res = drop(col, current);
      if (!res) return; // colonne pleine
      updateUI();
      const win = checkWin(res.r, res.c);
      if (win) return endGame(`Victoire de ${current===P1? 'üî¥ Rouge':'üü° Jaune'} ! üéâ`, win);
      if (isBoardFull()) return endGame('Match nul ü§ù');
      current = current===P1? P2 : P1;
      if (vsCPU && current===P2) setTimeout(cpuTurn, 120);
      else updateUI();
    }

    // --- IA Minimax avec √©lagage alpha-b√™ta ---
    function availableMoves(b){
      const arr = [];
      for (let c=0;c<COLS;c++) if (b[0][c]===0) arr.push(c);
      // Heuristique: ordre centr√© (meilleure performance)
      return arr.sort((a,b)=> Math.abs(a-3)-Math.abs(b-3));
    }

    function simulateDrop(b, c, player) {
      for (let r=ROWS-1;r>=0;r--) { if (b[r][c]===0) { b[r][c]=player; return r; } }
      return -1;
    }

    function undoSim(b, r, c){ b[r][c]=0; }

    // √âvaluation heuristique: score des alignements potentiels
    function evaluate(b, player) {
      const opponent = player===P1?P2:P1;
      const lines = [ [0,1], [1,0], [1,1], [1,-1] ];
      let score = 0;

      const weight = (countSelf, countOpp, empties) => {
        if (countSelf && countOpp) return 0; // bloqu√©
        const base = [0, 2, 6, 50, 5000]; // pond√©rations 0..4
        const c = countSelf ? countSelf : -countOpp;
        if (c>0) return base[c] + (empties>0? empties : 0);
        if (c<0) return -(base[-c] + (empties>0? empties : 0));
        return 0;
      };

      for (let r=0;r<ROWS;r++) {
        for (let c=0;c<COLS;c++) {
          for (const [dr,dc] of lines) {
            let countP=0, countO=0, empties=0;
            let cells=0;
            for (let k=0;k<WINLEN;k++){
              const rr=r+dr*k, cc=c+dc*k;
              if (!inBounds(rr,cc)) { cells=0; break; }
              const v=b[rr][cc];
              cells++;
              if (v===player) countP++; else if (v===opponent) countO++; else empties++;
            }
            if (cells===WINLEN) score += weight(countP, countO, empties);
          }
        }
      }
      // L√©g√®re pr√©f√©rence pour le centre
      for (let r=0;r<ROWS;r++) if (b[r][3]===player) score+=3;
      return score;
    }

    function terminal(b){
      // victoire / nul
      // Cherche une victoire en inspectant cases remplies
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (b[r][c]) {
        const line = checkWinGeneric(b, r, c);
        if (line) return {winner: b[r][c], line};
      }
      if (b[0].every(v=>v!==0)) return {draw:true};
      return null;
    }

    function checkWinGeneric(b, fromR, fromC) {
      const player = b[fromR][fromC];
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (const [dr,dc] of dirs) {
        let cells = [[fromR, fromC]];
        let r = fromR+dr, c = fromC+dc;
        while (inBounds(r,c) && b[r][c]===player) { cells.push([r,c]); r+=dr; c+=dc; }
        r = fromR-dr; c = fromC-dc;
        while (inBounds(r,c) && b[r][c]===player) { cells.push([r,c]); r-=dr; c-=dc; }
        if (cells.length >= WINLEN) return cells.slice(0, WINLEN);
      }
      return null;
    }

    function minimax(b, depth, alpha, beta, maximizing, player) {
      const term = terminal(b);
      if (term || depth===0) {
        if (term) {
          if (term.winner===player) return {score: 1e6, line: term.line};
          if (term.winner && term.winner!==player) return {score: -1e6, line: term.line};
          return {score: 0};
        }
        const sc = evaluate(b, player);
        return {score: sc};
      }

      const movesAvail = availableMoves(b);
      let bestMove = movesAvail[0];

      if (maximizing) {
        let value = -Infinity;
        for (const c of movesAvail) {
          const r = simulateDrop(b, c, player);
          if (r===-1) continue;
          const res = minimax(b, depth-1, alpha, beta, false, player);
          undoSim(b, r, c);
          if (res.score > value) { value = res.score; bestMove = c; }
          alpha = Math.max(alpha, value);
          if (alpha >= beta) break; // √©lagage
        }
        return {score: value, move: bestMove};
      } else {
        // Tour de l'adversaire
        const opp = player===P1?P2:P1;
        let value = Infinity;
        for (const c of movesAvail) {
          const r = simulateDrop(b, c, opp);
          if (r===-1) continue;
          const res = minimax(b, depth-1, alpha, beta, true, player);
          undoSim(b, r, c);
          if (res.score < value) { value = res.score; bestMove = c; }
          beta = Math.min(beta, value);
          if (alpha >= beta) break;
        }
        return {score: value, move: bestMove};
      }
    }

    function bestMove(level) {
      const depth = depthByLevel[level] ?? 3;

      // Niveau facile: 70% al√©atoire parmi coups valides, sinon minimax depth 1
      if (level === 'easy') {
        const avail = availableMoves(board);
        if (Math.random() < 0.7) return avail[Math.floor(Math.random()*avail.length)];
        return minimax(board.map(r=>r.slice()), 1, -Infinity, Infinity, true, P2).move ?? avail[0];
      }

      // Pour les autres, minimax alpha-b√™ta
      const clone = board.map(r=>r.slice());
      const res = minimax(clone, depth, -Infinity, Infinity, true, P2);
      return res.move ?? availableMoves(board)[0];
    }

    function cpuTurn() {
      if (gameOver || !vsCPU) return;
      const level = diffSel.value;

      // Blocage/prise imm√©diate (priorit√© avant minimax)
      const immediate = pickImmediateMove(P2) ?? pickImmediateBlock(P2);
      const c = immediate ?? bestMove(level);
      const res = drop(c, P2);
      if (!res) return; // s√©curit√©
      updateUI();
      const win = checkWin(res.r, res.c);
      if (win) return endGame('ü§ñ L\'IA gagne !', win);
      if (isBoardFull()) return endGame('Match nul ü§ù');
      current = P1;
      updateUI();
    }

    function pickImmediateMove(player){
      // Gagne-t-on maintenant ?
      for (const c of availableMoves(board)) {
        const r = simulateDrop(board, c, player);
        const w = checkWinGeneric(board, r, c);
        undoSim(board, r, c);
        if (w) return c;
      }
      return null;
    }

    function pickImmediateBlock(player){
      // Peut-on bloquer l'adversaire ?
      const opp = player===P1?P2:P1;
      for (const c of availableMoves(board)) {
        const r = simulateDrop(board, c, opp);
        const w = checkWinGeneric(board, r, c);
        undoSim(board, r, c);
        if (w) return c;
      }
      return null;
    }

    // Gestion des interactions
    boardEl.addEventListener('click', (e) => {
      const slot = e.target.closest('.slot');
      if (!slot) return;
      const col = +slot.dataset.col;
      handleHuman(col);
    });

    // Survol / fant√¥me (desktop)
    boardEl.addEventListener('mousemove', (e)=>{
      const slot = e.target.closest('.slot'); if (!slot) return;
      const col = +slot.dataset.col;
      showGhost(col);
    });
    boardEl.addEventListener('mouseleave', hideGhost);

    function showGhost(col){
      if (gameOver) return hideGhost();
      // Nettoie
      document.querySelectorAll('.ghost').forEach(g=>g.remove());
      // Ajoute un indicateur en haut de la colonne
      const topSlot = boardEl.children[col];
      const ghost = document.createElement('div');
      ghost.className = 'ghost ' + (current===P1?'p1':'p2');
      topSlot.appendChild(ghost);
    }
    function hideGhost(){ document.querySelectorAll('.ghost').forEach(g=>g.remove()); }

    // Clavier 1..7
    window.addEventListener('keydown', (e)=>{
      const n = parseInt(e.key, 10);
      if (!isNaN(n) && n>=1 && n<=7) handleHuman(n-1);
      if (e.key === 'u') undo();
      if (e.key === 'n') reset();
    });

    // Contr√¥les
    newBtn.addEventListener('click', reset);
    undoBtn.addEventListener('click', undo);

    modeCPU.addEventListener('click', ()=>{ vsCPU=true; modeCPU.setAttribute('aria-pressed','true'); modePVP.setAttribute('aria-pressed','false'); reset(false); });
    modePVP.addEventListener('click', ()=>{ vsCPU=false; modePVP.setAttribute('aria-pressed','true'); modeCPU.setAttribute('aria-pressed','false'); reset(false); });

    function reset(fresh=true){
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      moves = []; gameOver=false; current=P1;
      if (fresh) renderBoard(); else updateUI();
      statusEl.textContent = '√Ä toi de jouer üî¥';
    }

    // Initialisation
    renderBoard();
  </script>
</body>
</html>