<!-- 
peux-tu me proposer une page HTML complète proposant un jeu puissance 4 avec un design moderne, mettant en évidence les pions gagnants avec une animation fun et la possibilité de jouer contre l'ordinateur avec plusieurs niveau. L'interface doit être compatible avec les mobiles. Merci d'ajouter ce prompt en commentaire au début du code.
-->
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Puissance 4</title>
  <style>
    :root {
      --bg: #0f1226;
      --panel: #14183a;
      --panel-2: #1b2052;
      --accent: #7c5cff;
      --accent-2: #00e5ff;
      --p1: #ff3b5c;   /* rouge */
      --p2: #ffd83b;   /* jaune */
      --cell-size: min(12vw, 72px);
      --gap: clamp(6px, 1.2vw, 12px);
      --radius: 16px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 800px at 20% 0%, #10143a, #0a0d20 55%), var(--bg);
      color: #e9ecff; display: grid; place-items: center; min-height: 100svh;
    }
    .app {
      width: min(100%, 1100px); padding: 16px; display: grid; gap: 14px;
    }
    header {
      display: grid; gap: 8px; justify-items: center; text-align: center;
    }
    h1 { margin: 0; font-weight: 800; letter-spacing: .3px; font-size: clamp(22px, 4.2vw, 34px); }
    .sub { opacity:.8; font-size: .95rem; }

    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      padding: clamp(10px, 2.5vw, 18px);
    }

    .toolbar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; }
    .btn, select {
      background: #1e235a; color:#fff; border:1px solid rgba(255,255,255,.15);
      padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight:600; letter-spacing:.2px;
      transition: transform .05s ease, filter .2s ease, background .2s;
    }
    .btn:hover, select:hover { filter: brightness(1.1); }
    .btn:active { transform: translateY(1px); }
    .seg { display:flex; border:1px solid rgba(255,255,255,.15); border-radius:12px; overflow:hidden; }
    .seg button { background:#1e235a; border:0; padding:10px 12px; color:#fff; cursor:pointer; }
    .seg button[aria-pressed="true"] { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color:#0a0d20; font-weight:800; }

    .status { text-align:center; font-weight:700; margin-top:2px; }

    .board-wrap { display:grid; gap: var(--gap); justify-items:center; }
    .board {
      --cols: 7; --rows: 6;
      display:grid; grid-template-columns: repeat(var(--cols), var(--cell-size));
      grid-auto-rows: var(--cell-size);
      gap: var(--gap);
      padding: var(--gap);
      border-radius: calc(var(--radius) * 1.2);
      background: linear-gradient(180deg, #0d1140, #070a29);
      box-shadow: 0 12px 40px rgba(0,0,0,.45), inset 0 0 0 2px rgba(255,255,255,.05);
      position: relative;
      touch-action: manipulation;
      user-select: none;
    }

    .slot {
      width: var(--cell-size); height: var(--cell-size); position: relative; border-radius: 50%;
      background: radial-gradient(circle at 30% 25%, #263190 0%, #111545 55%, #0a0e2e 100%);
      box-shadow: inset 0 8px 18px rgba(0,0,0,.55), inset 0 -6px 14px rgba(255,255,255,.05);
      display:grid; place-items:center; overflow:visible;
    }

    .disc { width: 86%; height: 86%; border-radius: 50%; transform: translateY(-120%);
      box-shadow: inset 0 10px 18px rgba(255,255,255,.25), inset 0 -10px 14px rgba(0,0,0,.4), 0 8px 16px rgba(0,0,0,.35);
      transition: transform .22s cubic-bezier(.2,.8,.2,1);
      position: relative;
    }
    .disc.p1 { background: radial-gradient(circle at 30% 25%, #ff8aa0, var(--p1) 55%, #991a35); }
    .disc.p2 { background: radial-gradient(circle at 30% 25%, #fff2a1, var(--p2) 55%, #c1a316); }

    /* Ghost hover indicator */
    .ghost { position:absolute; top:-42px; left:50%; transform:translateX(-50%);
      width: 60%; height: 60%; border-radius:50%; opacity:.35; pointer-events:none; filter: drop-shadow(0 2px 6px rgba(0,0,0,.45));
    }
    .ghost.p1 { background: var(--p1); }
    .ghost.p2 { background: var(--p2); }

    /* Winning animation */
    @keyframes pop-glow {
      0%, 100% { transform: scale(1) rotate(0deg); box-shadow: 0 0 0 0 rgba(255,255,255,.0); }
      50% { transform: scale(1.12) rotate(2deg); box-shadow: 0 0 18px 6px rgba(255,255,255,.25); }
    }
    .win-ring::after { content:""; position:absolute; inset:-6px; border-radius:50%;
      background: conic-gradient(from 0deg, var(--accent), var(--accent-2), var(--accent)); opacity:.65; filter: blur(6px);
      animation: spin 1.8s linear infinite; z-index:0;
    }
    @keyframes spin { to { transform: rotate(1turn); } }
    .disc.win { animation: pop-glow 1.1s ease-in-out infinite; outline: 3px solid rgba(255,255,255,.25); position:relative; z-index:1; }

    /* Footer tips */
    .tips { opacity:.8; font-size:.9rem; text-align:center; }

    /* Responsive tweaks */
    @media (max-width: 520px) {
      :root { --cell-size: min(13.3vw, 64px); --gap: 8px; }
      .toolbar { gap:8px; }
      .btn, select { padding: 10px 12px; }
    }
  </style>
</head>
<body>
  <main class="app">
    <header>
      <h1>Puissance 4 <span style="font-weight:400; opacity:.85">– Mode Moderne + IA</span></h1>
      <div class="sub">Joue à deux ou affronte l'ordinateur (plusieurs niveaux). 100% compatible mobile.</div>
    </header>

    <section class="panel toolbar" aria-label="Contrôles">
      <div class="seg" role="group" aria-label="Mode de jeu">
        <button id="modePVP" aria-pressed="false" title="Deux joueurs">👥 2 joueurs</button>
        <button id="modeCPU" aria-pressed="true" title="Contre l'ordinateur">🤖 vs IA</button>
      </div>

      <label>
        Difficulté
        <select id="difficulty" title="Niveau IA">
          <option value="easy">Facile</option>
          <option value="medium" selected>Moyen</option>
          <option value="hard">Difficile</option>
          <option value="insane">Très difficile</option>
        </select>
      </label>

      <button class="btn" id="newGame">Nouvelle partie</button>
      <button class="btn" id="undoBtn" title="Annuler le dernier coup">Annuler</button>
    </section>

    <section class="panel board-wrap">
      <div id="status" class="status">À toi de jouer 🔴</div>
      <div id="board" class="board" role="grid" aria-label="Plateau Puissance 4"></div>
      <div class="tips">Astuce : touche 1–7 pour jouer une colonne. Sur mobile, tape simplement la colonne souhaitée.</div>
    </section>
  </main>

  <script>
    // --- Configuration du jeu ---
    const COLS = 7, ROWS = 6; // standard
    const P1 = 1, P2 = 2; // joueurs
    const WINLEN = 4;

    // Etat du jeu
    let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    let moves = []; // historique pour undo
    let current = P1;
    let gameOver = false;
    let vsCPU = true;

    // IA: profils de difficulté
    const depthByLevel = {
      easy: 1,
      medium: 3,
      hard: 4,
      insane: 6,
    };

    const statusEl = document.getElementById('status');
    const boardEl = document.getElementById('board');
    const diffSel = document.getElementById('difficulty');
    const modeCPU = document.getElementById('modeCPU');
    const modePVP = document.getElementById('modePVP');
    const newBtn = document.getElementById('newGame');
    const undoBtn = document.getElementById('undoBtn');

    // Construction visuelle du plateau
    function renderBoard() {
      boardEl.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const slot = document.createElement('div');
          slot.className = 'slot';
          slot.dataset.row = r; slot.dataset.col = c;
          const disc = document.createElement('div');
          disc.className = 'disc';
          slot.appendChild(disc);
          boardEl.appendChild(slot);
        }
      }
      updateUI();
    }

    function updateUI(winLine = null) {
      // Disques
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const idx = r * COLS + c;
          const slot = boardEl.children[idx];
          const disc = slot.querySelector('.disc');
          const val = board[r][c];
          disc.className = 'disc';
          if (val === P1) disc.classList.add('p1');
          else if (val === P2) disc.classList.add('p2');

          // Position d'animation (tomber dans le trou)
          if (val) disc.style.transform = 'translateY(0)'; else disc.style.transform = 'translateY(-120%)';
          slot.classList.toggle('win-ring', false);
        }
      }

      // Animation gagnante
      if (winLine) {
        for (const [r,c] of winLine) {
          const disc = boardEl.children[r*COLS + c].querySelector('.disc');
          disc.classList.add('win');
          boardEl.children[r*COLS + c].classList.add('win-ring');
        }
      } else {
        // Retire l'état win si on relance
        document.querySelectorAll('.disc.win').forEach(d => d.classList.remove('win'));
      }

      const turnStr = current === P1 ? '🔴 Rouge' : '🟡 Jaune';
      if (!gameOver) statusEl.textContent = (vsCPU && current===P2) ? 'L\'IA réfléchit… 🤖' : `À ${turnStr} de jouer`;
    }

    // Renvoie la ligne disponible la plus basse pour une colonne
    function nextRow(col) {
      for (let r = ROWS-1; r >= 0; r--) if (board[r][col] === 0) return r;
      return -1;
    }

    function drop(col, player) {
      const r = nextRow(col);
      if (r === -1) return false;
      board[r][col] = player;
      moves.push({r, c: col});
      return {r, c: col};
    }

    function undo() {
      if (!moves.length || gameOver) return;
      const last = moves.pop();
      board[last.r][last.c] = 0;
      current = current === P1 ? P2 : P1;
      updateUI();
      if (vsCPU && current === P2 && !gameOver) setTimeout(cpuTurn, 120);
    }

    function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

    function checkWin(fromR, fromC) {
      const player = board[fromR][fromC];
      if (!player) return null;
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (const [dr,dc] of dirs) {
        let cells = [[fromR, fromC]];
        // forward
        let r = fromR+dr, c = fromC+dc;
        while (inBounds(r,c) && board[r][c]===player) { cells.push([r,c]); r+=dr; c+=dc; }
        // backward
        r = fromR-dr; c = fromC-dc;
        while (inBounds(r,c) && board[r][c]===player) { cells.push([r,c]); r-=dr; c-=dc; }
        if (cells.length >= WINLEN) return cells.slice(0, WINLEN); // renvoie 4 cellules
      }
      return null;
    }

    function isBoardFull(){ return board[0].every(v => v!==0); }

    function endGame(message, winLine=null) {
      gameOver = true;
      if (winLine) updateUI(winLine); else updateUI();
      statusEl.textContent = message;
    }

    function handleHuman(col) {
      if (gameOver || (vsCPU && current===P2)) return;
      const res = drop(col, current);
      if (!res) return; // colonne pleine
      updateUI();
      const win = checkWin(res.r, res.c);
      if (win) return endGame(`Victoire de ${current===P1? '🔴 Rouge':'🟡 Jaune'} ! 🎉`, win);
      if (isBoardFull()) return endGame('Match nul 🤝');
      current = current===P1? P2 : P1;
      if (vsCPU && current===P2) setTimeout(cpuTurn, 120);
      else updateUI();
    }

    // --- IA Minimax avec élagage alpha-bêta ---
    function availableMoves(b){
      const arr = [];
      for (let c=0;c<COLS;c++) if (b[0][c]===0) arr.push(c);
      // Heuristique: ordre centré (meilleure performance)
      return arr.sort((a,b)=> Math.abs(a-3)-Math.abs(b-3));
    }

    function simulateDrop(b, c, player) {
      for (let r=ROWS-1;r>=0;r--) { if (b[r][c]===0) { b[r][c]=player; return r; } }
      return -1;
    }

    function undoSim(b, r, c){ b[r][c]=0; }

    // Évaluation heuristique: score des alignements potentiels
    function evaluate(b, player) {
      const opponent = player===P1?P2:P1;
      const lines = [ [0,1], [1,0], [1,1], [1,-1] ];
      let score = 0;

      const weight = (countSelf, countOpp, empties) => {
        if (countSelf && countOpp) return 0; // bloqué
        const base = [0, 2, 6, 50, 5000]; // pondérations 0..4
        const c = countSelf ? countSelf : -countOpp;
        if (c>0) return base[c] + (empties>0? empties : 0);
        if (c<0) return -(base[-c] + (empties>0? empties : 0));
        return 0;
      };

      for (let r=0;r<ROWS;r++) {
        for (let c=0;c<COLS;c++) {
          for (const [dr,dc] of lines) {
            let countP=0, countO=0, empties=0;
            let cells=0;
            for (let k=0;k<WINLEN;k++){
              const rr=r+dr*k, cc=c+dc*k;
              if (!inBounds(rr,cc)) { cells=0; break; }
              const v=b[rr][cc];
              cells++;
              if (v===player) countP++; else if (v===opponent) countO++; else empties++;
            }
            if (cells===WINLEN) score += weight(countP, countO, empties);
          }
        }
      }
      // Légère préférence pour le centre
      for (let r=0;r<ROWS;r++) if (b[r][3]===player) score+=3;
      return score;
    }

    function terminal(b){
      // victoire / nul
      // Cherche une victoire en inspectant cases remplies
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (b[r][c]) {
        const line = checkWinGeneric(b, r, c);
        if (line) return {winner: b[r][c], line};
      }
      if (b[0].every(v=>v!==0)) return {draw:true};
      return null;
    }

    function checkWinGeneric(b, fromR, fromC) {
      const player = b[fromR][fromC];
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (const [dr,dc] of dirs) {
        let cells = [[fromR, fromC]];
        let r = fromR+dr, c = fromC+dc;
        while (inBounds(r,c) && b[r][c]===player) { cells.push([r,c]); r+=dr; c+=dc; }
        r = fromR-dr; c = fromC-dc;
        while (inBounds(r,c) && b[r][c]===player) { cells.push([r,c]); r-=dr; c-=dc; }
        if (cells.length >= WINLEN) return cells.slice(0, WINLEN);
      }
      return null;
    }

    function minimax(b, depth, alpha, beta, maximizing, player) {
      const term = terminal(b);
      if (term || depth===0) {
        if (term) {
          if (term.winner===player) return {score: 1e6, line: term.line};
          if (term.winner && term.winner!==player) return {score: -1e6, line: term.line};
          return {score: 0};
        }
        const sc = evaluate(b, player);
        return {score: sc};
      }

      const movesAvail = availableMoves(b);
      let bestMove = movesAvail[0];

      if (maximizing) {
        let value = -Infinity;
        for (const c of movesAvail) {
          const r = simulateDrop(b, c, player);
          if (r===-1) continue;
          const res = minimax(b, depth-1, alpha, beta, false, player);
          undoSim(b, r, c);
          if (res.score > value) { value = res.score; bestMove = c; }
          alpha = Math.max(alpha, value);
          if (alpha >= beta) break; // élagage
        }
        return {score: value, move: bestMove};
      } else {
        // Tour de l'adversaire
        const opp = player===P1?P2:P1;
        let value = Infinity;
        for (const c of movesAvail) {
          const r = simulateDrop(b, c, opp);
          if (r===-1) continue;
          const res = minimax(b, depth-1, alpha, beta, true, player);
          undoSim(b, r, c);
          if (res.score < value) { value = res.score; bestMove = c; }
          beta = Math.min(beta, value);
          if (alpha >= beta) break;
        }
        return {score: value, move: bestMove};
      }
    }

    function bestMove(level) {
      const depth = depthByLevel[level] ?? 3;

      // Niveau facile: 70% aléatoire parmi coups valides, sinon minimax depth 1
      if (level === 'easy') {
        const avail = availableMoves(board);
        if (Math.random() < 0.7) return avail[Math.floor(Math.random()*avail.length)];
        return minimax(board.map(r=>r.slice()), 1, -Infinity, Infinity, true, P2).move ?? avail[0];
      }

      // Pour les autres, minimax alpha-bêta
      const clone = board.map(r=>r.slice());
      const res = minimax(clone, depth, -Infinity, Infinity, true, P2);
      return res.move ?? availableMoves(board)[0];
    }

    function cpuTurn() {
      if (gameOver || !vsCPU) return;
      const level = diffSel.value;

      // Blocage/prise immédiate (priorité avant minimax)
      const immediate = pickImmediateMove(P2) ?? pickImmediateBlock(P2);
      const c = immediate ?? bestMove(level);
      const res = drop(c, P2);
      if (!res) return; // sécurité
      updateUI();
      const win = checkWin(res.r, res.c);
      if (win) return endGame('🤖 L\'IA gagne !', win);
      if (isBoardFull()) return endGame('Match nul 🤝');
      current = P1;
      updateUI();
    }

    function pickImmediateMove(player){
      // Gagne-t-on maintenant ?
      for (const c of availableMoves(board)) {
        const r = simulateDrop(board, c, player);
        const w = checkWinGeneric(board, r, c);
        undoSim(board, r, c);
        if (w) return c;
      }
      return null;
    }

    function pickImmediateBlock(player){
      // Peut-on bloquer l'adversaire ?
      const opp = player===P1?P2:P1;
      for (const c of availableMoves(board)) {
        const r = simulateDrop(board, c, opp);
        const w = checkWinGeneric(board, r, c);
        undoSim(board, r, c);
        if (w) return c;
      }
      return null;
    }

    // Gestion des interactions
    boardEl.addEventListener('click', (e) => {
      const slot = e.target.closest('.slot');
      if (!slot) return;
      const col = +slot.dataset.col;
      handleHuman(col);
    });

    // Survol / fantôme (desktop)
    boardEl.addEventListener('mousemove', (e)=>{
      const slot = e.target.closest('.slot'); if (!slot) return;
      const col = +slot.dataset.col;
      showGhost(col);
    });
    boardEl.addEventListener('mouseleave', hideGhost);

    function showGhost(col){
      if (gameOver) return hideGhost();
      // Nettoie
      document.querySelectorAll('.ghost').forEach(g=>g.remove());
      // Ajoute un indicateur en haut de la colonne
      const topSlot = boardEl.children[col];
      const ghost = document.createElement('div');
      ghost.className = 'ghost ' + (current===P1?'p1':'p2');
      topSlot.appendChild(ghost);
    }
    function hideGhost(){ document.querySelectorAll('.ghost').forEach(g=>g.remove()); }

    // Clavier 1..7
    window.addEventListener('keydown', (e)=>{
      const n = parseInt(e.key, 10);
      if (!isNaN(n) && n>=1 && n<=7) handleHuman(n-1);
      if (e.key === 'u') undo();
      if (e.key === 'n') reset();
    });

    // Contrôles
    newBtn.addEventListener('click', reset);
    undoBtn.addEventListener('click', undo);

    modeCPU.addEventListener('click', ()=>{ vsCPU=true; modeCPU.setAttribute('aria-pressed','true'); modePVP.setAttribute('aria-pressed','false'); reset(false); });
    modePVP.addEventListener('click', ()=>{ vsCPU=false; modePVP.setAttribute('aria-pressed','true'); modeCPU.setAttribute('aria-pressed','false'); reset(false); });

    function reset(fresh=true){
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      moves = []; gameOver=false; current=P1;
      if (fresh) renderBoard(); else updateUI();
      statusEl.textContent = 'À toi de jouer 🔴';
    }

    // Initialisation
    renderBoard();
  </script>
</body>
</html>